#include <bits/stdc++.h>
using namespace std;

class Node{
    public:
    int data;
    Node* left;
    Node* right;
    
    Node(int val){
        data = val;
        left = right = NULL;
    }
};
static int idx = -1;
Node* buildTree(vector<int>preorder){

    idx++;
    if(preorder[idx] == -1){
        return NULL;
    }
        Node* root = new Node(preorder[idx]);
        root->left = buildTree(preorder); //creates left subtree
        root->right = buildTree(preorder); //creates rigth subtree
        return root; //connect the builded subroot to above roots
        
}
void preorderTree(Node* root) {
    if (!root) return;
    cout << root->data << " ";
    preorderTree(root->left);
    preorderTree(root->right);
}

void InorderTree(Node* root) {
    if (root == NULL) return;
    InorderTree(root->left);
    cout << root->data << " ";
    InorderTree(root->right);

}
void Postorder(Node* root){
    if(root == NULL)
    {
        return ;
    }
    Postorder(root->left);
    Postorder(root->right);
    cout<<root->data<<" ";
}
void Levelorder(Node*root)
{
    queue<Node*>q;
    q.push(root);
    q.push(NULL);//for printing vertically level by level using NULL
    while(q.size()>0)
    {
       Node*curr = q.front();
       q.pop();
       if(curr == NULL) //only curr not curr->data cause NULL is ptr and we can't compare it with integer we need the whole node
       {
           if(!q.empty()){
               cout<<endl;
               q.push(NULL);
               continue;
           }
           else{
               break;
           }
       }
       cout<<curr->data<<" ";
       if(curr->left != NULL)
       {
           q.push(curr->left);
       }
       if(curr->right != NULL)
       {
           q.push(curr->right);
       }
    }
}
int main() {
	vector<int>preorder = {1,2,-1,-1,3,4,-1,-1,5,-1,-1};
	Node*root = buildTree(preorder);
	cout << "\nPreorder: ";
    preorderTree(root);
    cout<<endl;
    InorderTree(root);
    cout<<endl;
    Postorder(root);
    cout<<endl;
    Levelorder(root);
// 	cout<<root->data;
// 	cout<<root->left->data;
// 	cout<<root->right->data;
	
	
	return 0;
}
