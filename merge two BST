#include <bits/stdc++.h>
using namespace std;
class Node{
    public:
    int data;
    Node*left;
    Node*right;
    Node(int val){
        data = val;
        left = right = NULL;
    }
    
};
Node* insert(Node*root,int val){
    if(root == NULL) return new Node(val);//for new node if there is no node at that palce
    if(val <root->data){ //if less then left node
        root->left = insert(root->left,val);
    }
    else{
        root->right = insert(root->right,val); //else here
    }
    return root; //then after placeing each node retures the top most node
}

    Node* buildBST(vector<int> arr){
        Node* root = NULL;
        for(int val:arr){
            root = insert(root,val); //we need the root everytime to check
        }
        return root;
    }
    
Node* buildBSTfromsorted(vector<int>& temp,int st,int e){
    if(st>e) return NULL;
    int mid = st+(e-st)/2;
    Node* root = new Node(temp[mid]);
    root->left = buildBSTfromsorted(temp,st,mid-1);
    root->right = buildBSTfromsorted(temp,mid+1,e);
    return root;
}
void inorder(Node*root,vector<int>& arr){
    if(root == NULL) return ;
    inorder(root->left,arr);
    arr.push_back(root->data);
    inorder(root->right,arr);
}
Node* mergeBST(Node* root1,Node* root2){
    vector<int>arr1,arr2;
    inorder(root1,arr1);
    inorder(root2,arr2);
    vector<int>temp;
    int i = 0,j = 0;
    
    while(i<arr1.size()&&j<arr2.size()){
        if(arr1[i]<arr2[j]){
            temp.push_back(arr1[i++]);
        }
        else{
            temp.push_back(arr2[j++]);
        }
        

    }
    while(i<arr1.size()){
        temp.push_back(arr1[i++]);
    }
     while(j<arr2.size()){
        temp.push_back(arr2[j++]);
    }
   return buildBSTfromsorted(temp,0,temp.size()-1);
}
    void inordertravelsal(Node*root){
        if(root == NULL) return ;
        inordertravelsal(root->left);
        cout<<root->data<<" ";
        inordertravelsal(root->right);
    }
int main() {
	// your code goes here
     vector<int>arr1 = {8,2,10,1};
     vector<int>arr2 = {5,3,0};
     Node* root1 = buildBST(arr1);
     Node* root2 = buildBST(arr2);
     
     Node* parent = mergeBST(root1,root2);
     inordertravelsal(parent);
}
